📤 دفعة أوامر واحدة للـ Replit Agent (انسخها كما هي)

الهدف: إصلاح قطعي 100% لتدفق المطابقة عبر REST بإضافة fallback ذاكرة عند غياب Upstash، ثم فحص القبول، ثم إرشادات ضبط البيئة للعودة إلى وضع redis.
القواعد: Minimal‑Diff، لا حذف لميزة، لا تغييرات شكلية، إصلاح أي تحذير بسيط محلياً دون المساس بالمنطق.

#!/usr/bin/env bash
set -euo pipefail

echo "=== 0) فرع عمل آمن ==="
git checkout -b feature/rtc-upstash-mem-fallback || git checkout feature/rtc-upstash-mem-fallback || true
mkdir -p _ops/backup || true

echo "=== 1) نسخ احتياطي للملفات المستهدفة ==="
for f in \
  src/lib/rtc/upstash.ts \
  src/app/api/rtc/qlen/route.ts \
  src/app/api/rtc/enqueue/route.ts \
  src/app/api/rtc/matchmake/route.ts \
  src/app/api/rtc/offer/route.ts \
  src/app/api/rtc/answer/route.ts \
  src/app/api/rtc/ice/route.ts \
  _ops/acc_rtc.sh \
; do
  cp -f "$f" "_ops/backup/$(echo "$f" | tr '/' '_').bak" 2>/dev/null || true
done

echo "=== 2) باتش upstash.ts — إضافة ذاكرة بديلة + MODE ==="
cat > src/lib/rtc/upstash.ts <<'TS'
// "use server";
import { NextResponse } from "next/server";

/** Upstash REST config (switch to in-memory if missing) */
const URL = process.env.UPSTASH_REDIS_REST_URL || "";
const TOKEN = process.env.UPSTASH_REDIS_REST_TOKEN || "";
export const MODE: "redis" | "memory" = (URL && TOKEN) ? "redis" : "memory";

/* -------- In-memory fallback -------- */
type Entry = { type: "str"|"hash"|"set"|"zset"|"list"|"ctr"; val: any; exp?: number };
const memStore: Map<string, Entry> = (globalThis as any).__DITO_MEM__ ||= new Map();
const now = () => Date.now();
function alive(key: string): Entry | undefined {
  const e = memStore.get(key);
  if (!e) return;
  if (e.exp && e.exp <= now()) { memStore.delete(key); return; }
  return e;
}
function setE(key: string, e: Entry) { memStore.set(key, e); }
function ensure<T extends Entry["type"]>(key: string, type: T): Entry {
  const e = alive(key);
  if (!e) { const n: Entry = { type, val: (type==="hash"?{}: type==="set"? new Set(): type==="zset"? new Map(): type==="list"? []: 0) }; setE(key, n); return n; }
  if (e.type !== type) { const n: Entry = { type, val: (type==="hash"?{}: type==="set"? new Set(): type==="zset"? new Map(): type==="list"? []: 0) }; setE(key, n); return n; }
  return e;
}

/* -------- Redis pipeline over REST -------- */
type Cmd = (string | number)[];
async function pipe(commands: Cmd[]) {
  if (MODE === "memory") throw new Error("MEMORY_MODE");
  const r = await fetch(`${URL}/pipeline`, {
    method: "POST",
    headers: { "content-type": "application/json", authorization: `Bearer ${TOKEN}` },
    body: JSON.stringify({ commands }),
    cache: "no-store",
  });
  if (!r.ok) {
    const text = await r.text();
    throw new Error(`[upstash] ${r.status} ${text}`);
  }
  const json = await r.json();
  return json.map((e: any) => e.result);
}

/* -------- Helpers exported (redis | memory) -------- */
export async function setNxPx(key: string, val: string, px: number) {
  if (MODE === "memory") {
    if (alive(key)) return false;
    setE(key, { type:"str", val, exp: now()+px }); return true;
  }
  const [res] = await pipe([["SET", key, val, "NX", "PX", px]]);
  return res === "OK";
}
export async function setPx(key: string, val: string, px: number) {
  if (MODE === "memory") { setE(key, { type:"str", val, exp: now()+px }); return true; }
  const [res] = await pipe([["SET", key, val, "PX", px]]); return res === "OK";
}
export async function set(key: string, val: string) {
  if (MODE === "memory") { setE(key, { type:"str", val }); return true; }
  const [res] = await pipe([["SET", key, val]]); return res === "OK";
}
export async function get(key: string) {
  if (MODE === "memory") { return alive(key)?.val ?? null; }
  const [res] = await pipe([["GET", key]]); return res ?? null;
}
export async function del(key: string) {
  if (MODE === "memory") { memStore.delete(key); return; }
  await pipe([["DEL", key]]);
}
export async function expire(key: string, s: number) {
  if (MODE === "memory") { const e = alive(key); if (e) e.exp = now()+s*1000; return; }
  await pipe([["EXPIRE", key, s]]);
}
export async function exists(key: string) {
  if (MODE === "memory") { return alive(key) ? 1 : 0; }
  const [n] = await pipe([["EXISTS", key]]); return n === 1;
}

/* hashes */
export async function hset(key: string, obj: Record<string, string | number>) {
  if (MODE === "memory") {
    const e = ensure(key, "hash"); for (const [k,v] of Object.entries(obj)) (e.val as any)[k]=String(v); return;
  }
  const flat:(string|number)[]=[]; Object.entries(obj).forEach(([k,v])=>flat.push(k,String(v)));
  await pipe([["HSET", key, ...flat]]);
}
export async function hgetall(key: string): Promise<Record<string,string>> {
  if (MODE === "memory") { return Object.assign({}, (alive(key)?.val||{})); }
  const [arr] = await pipe([["HGETALL", key]]);
  const out: Record<string,string> = {}; if (Array.isArray(arr)) for(let i=0;i<arr.length;i+=2) out[arr[i]]=arr[i+1];
  return out;
}

/* sets */
export async function sadd(key: string, member: string) {
  if (MODE === "memory") { const e=ensure(key,"set"); (e.val as Set<string>).add(member); return; }
  await pipe([["SADD", key, member]]);
}
export async function sismember(key: string, member: string) {
  if (MODE === "memory") { const e=alive(key); return e?.type==="set" && (e.val as Set<string>).has(member) ? 1:0; }
  const [n] = await pipe([["SISMEMBER", key, member]]); return n === 1;
}

/* zsets */
export async function zadd(key: string, score: number, member: string) {
  if (MODE === "memory") { const e=ensure(key,"zset"); (e.val as Map<string,number>).set(member,score); return; }
  await pipe([["ZADD", key, score, member]]);
}
export async function zrem(key: string, member: string) {
  if (MODE === "memory") { const e=alive(key); if (e?.type==="zset") (e.val as Map<string,number>).delete(member); return; }
  await pipe([["ZREM", key, member]]);
}
export async function zcard(key: string) {
  if (MODE === "memory") { const e=alive(key); return e?.type==="zset" ? (e.val as Map<string,number>).size : 0; }
  const [n] = await pipe([["ZCARD", key]]); return Number(n||0);
}
export async function zrange(key: string, start=0, stop=49): Promise<string[]> {
  if (MODE === "memory") {
    const e=alive(key); if (e?.type!=="zset") return [];
    const arr=[... (e.val as Map<string,number>).entries()].sort((a,b)=>a[1]-b[1]).map(([m])=>m);
    return arr.slice(start, stop+1);
  }
  const [res] = await pipe([["ZRANGE", key, start, stop]]);
  return Array.isArray(res)? res: [];
}
function parseScore(s: string){ let excl=false; if (s.startsWith("(")){ excl=true; s=s.slice(1); }
  if (s==="inf"||s==="+inf") return {v:Infinity,excl}; if (s==="-inf") return {v:-Infinity,excl};
  return {v: Number(s), excl};
}
export async function zremrangebyscore(key: string, min: string, max: string) {
  if (MODE === "memory") {
    const e=alive(key); if (e?.type!=="zset") return;
    const {v:mn,excl:exMn}=parseScore(min), {v:mx,excl:exMx}=parseScore(max);
    const z = e.val as Map<string,number>;
    for (const [m,sc] of [...z.entries()]) {
      const geMin = exMn ? sc>mn : sc>=mn;
      const leMax = exMx ? sc<mx : sc<=mx;
      if (geMin && leMax) z.delete(m);
    }
    return;
  }
  await pipe([["ZREMRANGEBYSCORE", key, min, max]]);
}

/* lists */
export async function lpush(key: string, val: string) {
  if (MODE === "memory") { const e=ensure(key,"list"); (e.val as string[]).unshift(val); return; }
  await pipe([["LPUSH", key, val]]);
}
export async function lrange(key: string, start=0, stop=49) {
  if (MODE === "memory") { const e=alive(key); const a=e?.type==="list"?(e.val as string[]):[]; return a.slice(start, stop+1); }
  const [res] = await pipe([["LRANGE", key, start, stop]]); return Array.isArray(res)? res: [];
}
export async function ltrim(key: string, start: number, stop: number) {
  if (MODE === "memory") { const e=alive(key); if (e?.type==="list") e.val=(e.val as string[]).slice(start, stop+1); return; }
  await pipe([["LTRIM", key, start, stop]]);
}

/* simple counter rate limit: limit N/ windowSec */
export async function rateLimit(key: string, limit: number, windowSec: number) {
  if (MODE === "memory") {
    const bucket = `__rl:${key}:${Math.floor(now()/(windowSec*1000))}`;
    const e = ensure(bucket,"ctr"); e.val = Number(e.val||0) + 1; e.exp = now()+windowSec*1000;
    return e.val <= limit;
  }
  const bucket = `rl:${key}:${Math.floor(Date.now()/(windowSec*1000))}`;
  const res = await pipe([["INCR", bucket], ["EXPIRE", bucket, windowSec]]);
  const count = Number(res?.[0] || 0);
  return count <= limit;
}
TS

echo "=== 3) qlen: الإبلاغ عن MODE فعلي (redis|memory) مع عدم رمي 500 ==="
cat > src/app/api/rtc/qlen/route.ts <<'TS'
import { NextResponse } from "next/server";
import { zcard, zremrangebyscore, MODE } from "@/lib/rtc/upstash";
export const runtime = "nodejs";
export async function GET() {
  try {
    const cutoff = Date.now() - 60_000;
    await zremrangebyscore(`rtc:q`, "-inf", `(${cutoff}`);
    const len = await zcard(`rtc:q`);
    return NextResponse.json({ mode: MODE, len: Number(len || 0) }, { status: 200 });
  } catch (e: any) {
    return NextResponse.json({ mode: MODE === "redis" ? "redis-fail" : "memory", len: 0, error: String(e?.message||e).slice(0,120) }, { status: 200 });
  }
}
TS

echo "=== 4) سكربت قبول مُحدّث (يعمل على الذاكرة أو رِدِس) ==="
mkdir -p _ops || true
cat > _ops/acc_rtc.sh <<'SH'
#!/usr/bin/env bash
set -euo pipefail
BASE="${1:-https://www.ditonachat.com}"
say(){ printf "\n== %s ==\n" "$*"; }
code(){ curl -s -o /dev/null -w "%{http_code}" "$@"; }
json(){ curl -s "$@"; }
TMPDIR="${TMPDIR:-/tmp}"
JAR_A="$TMPDIR/ditona_anon_A.jar"; JAR_B="$TMPDIR/ditona_anon_B.jar"
rm -f "$JAR_A" "$JAR_B"

say "1) Init anon cookies"
curl -s -c "$JAR_A" "$BASE/api/anon/init" >/dev/null
curl -s -c "$JAR_B" "$BASE/api/anon/init" >/dev/null

say "2) Queue mode"
MODE=$(curl -s "$BASE/api/rtc/qlen" | sed -n 's/.*"mode":"\([^"]\+\)".*/\1/p'); echo "MODE=$MODE"

say "3) Enqueue A/B"
code -b "$JAR_A" -H "content-type: application/json" -X POST -d '{"gender":"u","country":"US","filterGenders":"all","filterCountries":"ALL"}' "$BASE/api/rtc/enqueue" | xargs echo "A enqueue:"
code -b "$JAR_B" -H "content-type: application/json" -X POST -d '{"gender":"u","country":"US","filterGenders":"all","filterCountries":"ALL"}' "$BASE/api/rtc/enqueue" | xargs echo "B enqueue:"

say "4) Matchmake"
R_A=$(curl -s -b "$JAR_A" -X POST "$BASE/api/rtc/matchmake"); echo "A: $R_A"
PAIR=$(echo "$R_A" | sed -n 's/.*"pairId":"\([^"]\+\)".*/\1/p'); ROLE_A=$(echo "$R_A" | sed -n 's/.*"role":"\([^"]\+\)".*/\1/p')
R_B=$(curl -s -b "$JAR_B" -X POST "$BASE/api/rtc/matchmake"); echo "B: $R_B"
PAIR_B=$(echo "$R_B" | sed -n 's/.*"pairId":"\([^"]\+\)".*/\1/p'); ROLE_B=$(echo "$R_B" | sed -n 's/.*"role":"\([^"]\+\)".*/\1/p')
echo "Expected: same pairId; roles caller/callee"
echo "Actual:   A:$PAIR ($ROLE_A)  B:$PAIR_B ($ROLE_B)"
test -n "$PAIR" && [ "$PAIR" = "$PAIR_B" ] || { echo "✗ Matchmake failed"; exit 1; }

say "5) Offer/Answer"
code -b "$JAR_A" -H "content-type: application/json" -X POST -d "{\"pairId\":\"$PAIR\",\"sdp\":\"v=0-dummy-offer\"}" "$BASE/api/rtc/offer" | xargs echo "A POST /offer:"
curl -s -b "$JAR_B" "$BASE/api/rtc/offer?pairId=$PAIR" | sed 's/.*/B GET \/offer: &/'
code -b "$JAR_B" -H "content-type: application/json" -X POST -d "{\"pairId\":\"$PAIR\",\"sdp\":\"v=0-dummy-answer\"}" "$BASE/api/rtc/answer" | xargs echo "B POST /answer:"
curl -s -b "$JAR_A" "$BASE/api/rtc/answer?pairId=$PAIR" | sed 's/.*/A GET \/answer: &/'

say "6) ICE exchange"
code -b "$JAR_A" -H "content-type: application/json" -X POST -d "{\"pairId\":\"$PAIR\",\"candidate\":{\"candidate\":\"candA\",\"sdpMid\":\"0\",\"sdpMLineIndex\":0}}" "$BASE/api/rtc/ice" | xargs echo "A POST /ice:"
curl -s -b "$JAR_B" "$BASE/api/rtc/ice?pairId=$PAIR" | sed 's/.*/B GET \/ice: &/'
code -b "$JAR_B" -H "content-type: application/json" -X POST -d "{\"pairId\":\"$PAIR\",\"candidate\":{\"candidate\":\"candB\",\"sdpMid\":\"0\",\"sdpMLineIndex\":0}}" "$BASE/api/rtc/ice" | xargs echo "B POST /ice:"
curl -s -b "$JAR_A" "$BASE/api/rtc/ice?pairId=$PAIR" | sed 's/.*/A GET \/ice: &/'

say "7) qlen (final)"
curl -s "$BASE/api/rtc/qlen" | sed 's/.*/qlen: &/'

say "SUMMARY"
echo "MODE=$MODE (memory during bring-up; expected 'redis' after env fix)"
echo "Match + SDP/ICE via REST OK if above steps succeeded."
SH
chmod +x _ops/acc_rtc.sh

echo "=== 5) تثبيت وبناء ==="
pnpm install
pnpm build

echo "=== 6) تشغيل القبول على الإنتاج ==="
bash _ops/acc_rtc.sh https://www.ditonachat.com || (echo 'ACCEPTANCE FAILED' && exit 1)

echo "=== 7) التزام التغييرات ==="
git add -A
git commit -m "RTC: Upstash memory fallback + qlen mode; acceptance script"
echo "DONE. افتح PR إلى main مع لقطات/نتائج acc."

🧪 ما الذي سنتحقق منه بعد تطبيق الباتش؟

لن ترى 500 على /api/rtc/enqueue|matchmake|qlen حتى بدون مفاتيح Upstash.

/api/rtc/qlen سيعرض {"mode":"memory","len":...} بدلاً من redis-fail.

تشغيل bash _ops/acc_rtc.sh https://www.ditonachat.com يجب أن يُظهر:

pairId واحد للطرفين (caller/callee).

نجاح offer/answer/ice (POST=204 أو 409، وGET يعيد JSON/array).

ثم يمكنك التأكد بصريًا من جهازين أن الفيديو يعمل.

لو فشل acc_rtc.sh بعد هذه الدفعة: أرسل لنا نص الخرج الكامل. الفشل الوحيد المتوقع الآن هو عدم وجود كوكي anon (نادر؛ init يُعالجه)، أو خطأ JS في الواجهة خارج هذا المسار.

🔧 الخطوة التالية (إلزامية لعودة الوضع إلى Redis)

بعد أن تتأكد أن الاتصال يعمل في memory:

ادخل Vercel → Project → Settings → Environment Variables وأضف في Production + Preview:

UPSTASH_REDIS_REST_URL

UPSTASH_REDIS_REST_TOKEN

أعد النشر.

تحقق:

curl -s https://www.ditonachat.com/api/rtc/qlen | jq .
# Expected: { "mode": "redis", "len": ... }


أعد تشغيل bash _ops/acc_rtc.sh https://www.ditonachat.com وتأكد من المرور (النتيجة الآن MODE=redis).

مهم: الـfallback الذاكري حل تشغيل مؤقت لتفادي 500 فورًا وتمكين الاختبار؛ نعود إلى Redis بمجرد ضبط المتغيرات. لا توجد تغييرات إضافية مطلوبة.

🧾 تقرير مطلوب من الوكيل بعد الانتهاء

قائمة الملفات المعدّلة (مع الإشارة للنسخ الاحتياطية في _ops/backup).

مخرجات acc_rtc.sh (Expected/Actual + MODE).

لقطة شاشة من جهازين أثناء اتصال فعلي.

تأكيد أن لا ميزة حُذفت ولا تغييرات بصرية حدثت.