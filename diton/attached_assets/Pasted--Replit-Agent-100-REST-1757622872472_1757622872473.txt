ğŸ“¤ Ø¯ÙØ¹Ø© Ø£ÙˆØ§Ù…Ø± ÙˆØ§Ø­Ø¯Ø© Ù„Ù„Ù€ Replit Agent (Ø§Ù†Ø³Ø®Ù‡Ø§ ÙƒÙ…Ø§ Ù‡ÙŠ)

Ø§Ù„Ù‡Ø¯Ù: Ø¥ØµÙ„Ø§Ø­ Ù‚Ø·Ø¹ÙŠ 100% Ù„ØªØ¯ÙÙ‚ Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© Ø¹Ø¨Ø± REST Ø¨Ø¥Ø¶Ø§ÙØ© fallback Ø°Ø§ÙƒØ±Ø© Ø¹Ù†Ø¯ ØºÙŠØ§Ø¨ UpstashØŒ Ø«Ù… ÙØ­Øµ Ø§Ù„Ù‚Ø¨ÙˆÙ„ØŒ Ø«Ù… Ø¥Ø±Ø´Ø§Ø¯Ø§Øª Ø¶Ø¨Ø· Ø§Ù„Ø¨ÙŠØ¦Ø© Ù„Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ ÙˆØ¶Ø¹ redis.
Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯: Minimalâ€‘DiffØŒ Ù„Ø§ Ø­Ø°Ù Ù„Ù…ÙŠØ²Ø©ØŒ Ù„Ø§ ØªØºÙŠÙŠØ±Ø§Øª Ø´ÙƒÙ„ÙŠØ©ØŒ Ø¥ØµÙ„Ø§Ø­ Ø£ÙŠ ØªØ­Ø°ÙŠØ± Ø¨Ø³ÙŠØ· Ù…Ø­Ù„ÙŠØ§Ù‹ Ø¯ÙˆÙ† Ø§Ù„Ù…Ø³Ø§Ø³ Ø¨Ø§Ù„Ù…Ù†Ø·Ù‚.

#!/usr/bin/env bash
set -euo pipefail

echo "=== 0) ÙØ±Ø¹ Ø¹Ù…Ù„ Ø¢Ù…Ù† ==="
git checkout -b feature/rtc-upstash-mem-fallback || git checkout feature/rtc-upstash-mem-fallback || true
mkdir -p _ops/backup || true

echo "=== 1) Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠ Ù„Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ© ==="
for f in \
  src/lib/rtc/upstash.ts \
  src/app/api/rtc/qlen/route.ts \
  src/app/api/rtc/enqueue/route.ts \
  src/app/api/rtc/matchmake/route.ts \
  src/app/api/rtc/offer/route.ts \
  src/app/api/rtc/answer/route.ts \
  src/app/api/rtc/ice/route.ts \
  _ops/acc_rtc.sh \
; do
  cp -f "$f" "_ops/backup/$(echo "$f" | tr '/' '_').bak" 2>/dev/null || true
done

echo "=== 2) Ø¨Ø§ØªØ´ upstash.ts â€” Ø¥Ø¶Ø§ÙØ© Ø°Ø§ÙƒØ±Ø© Ø¨Ø¯ÙŠÙ„Ø© + MODE ==="
cat > src/lib/rtc/upstash.ts <<'TS'
// "use server";
import { NextResponse } from "next/server";

/** Upstash REST config (switch to in-memory if missing) */
const URL = process.env.UPSTASH_REDIS_REST_URL || "";
const TOKEN = process.env.UPSTASH_REDIS_REST_TOKEN || "";
export const MODE: "redis" | "memory" = (URL && TOKEN) ? "redis" : "memory";

/* -------- In-memory fallback -------- */
type Entry = { type: "str"|"hash"|"set"|"zset"|"list"|"ctr"; val: any; exp?: number };
const memStore: Map<string, Entry> = (globalThis as any).__DITO_MEM__ ||= new Map();
const now = () => Date.now();
function alive(key: string): Entry | undefined {
  const e = memStore.get(key);
  if (!e) return;
  if (e.exp && e.exp <= now()) { memStore.delete(key); return; }
  return e;
}
function setE(key: string, e: Entry) { memStore.set(key, e); }
function ensure<T extends Entry["type"]>(key: string, type: T): Entry {
  const e = alive(key);
  if (!e) { const n: Entry = { type, val: (type==="hash"?{}: type==="set"? new Set(): type==="zset"? new Map(): type==="list"? []: 0) }; setE(key, n); return n; }
  if (e.type !== type) { const n: Entry = { type, val: (type==="hash"?{}: type==="set"? new Set(): type==="zset"? new Map(): type==="list"? []: 0) }; setE(key, n); return n; }
  return e;
}

/* -------- Redis pipeline over REST -------- */
type Cmd = (string | number)[];
async function pipe(commands: Cmd[]) {
  if (MODE === "memory") throw new Error("MEMORY_MODE");
  const r = await fetch(`${URL}/pipeline`, {
    method: "POST",
    headers: { "content-type": "application/json", authorization: `Bearer ${TOKEN}` },
    body: JSON.stringify({ commands }),
    cache: "no-store",
  });
  if (!r.ok) {
    const text = await r.text();
    throw new Error(`[upstash] ${r.status} ${text}`);
  }
  const json = await r.json();
  return json.map((e: any) => e.result);
}

/* -------- Helpers exported (redis | memory) -------- */
export async function setNxPx(key: string, val: string, px: number) {
  if (MODE === "memory") {
    if (alive(key)) return false;
    setE(key, { type:"str", val, exp: now()+px }); return true;
  }
  const [res] = await pipe([["SET", key, val, "NX", "PX", px]]);
  return res === "OK";
}
export async function setPx(key: string, val: string, px: number) {
  if (MODE === "memory") { setE(key, { type:"str", val, exp: now()+px }); return true; }
  const [res] = await pipe([["SET", key, val, "PX", px]]); return res === "OK";
}
export async function set(key: string, val: string) {
  if (MODE === "memory") { setE(key, { type:"str", val }); return true; }
  const [res] = await pipe([["SET", key, val]]); return res === "OK";
}
export async function get(key: string) {
  if (MODE === "memory") { return alive(key)?.val ?? null; }
  const [res] = await pipe([["GET", key]]); return res ?? null;
}
export async function del(key: string) {
  if (MODE === "memory") { memStore.delete(key); return; }
  await pipe([["DEL", key]]);
}
export async function expire(key: string, s: number) {
  if (MODE === "memory") { const e = alive(key); if (e) e.exp = now()+s*1000; return; }
  await pipe([["EXPIRE", key, s]]);
}
export async function exists(key: string) {
  if (MODE === "memory") { return alive(key) ? 1 : 0; }
  const [n] = await pipe([["EXISTS", key]]); return n === 1;
}

/* hashes */
export async function hset(key: string, obj: Record<string, string | number>) {
  if (MODE === "memory") {
    const e = ensure(key, "hash"); for (const [k,v] of Object.entries(obj)) (e.val as any)[k]=String(v); return;
  }
  const flat:(string|number)[]=[]; Object.entries(obj).forEach(([k,v])=>flat.push(k,String(v)));
  await pipe([["HSET", key, ...flat]]);
}
export async function hgetall(key: string): Promise<Record<string,string>> {
  if (MODE === "memory") { return Object.assign({}, (alive(key)?.val||{})); }
  const [arr] = await pipe([["HGETALL", key]]);
  const out: Record<string,string> = {}; if (Array.isArray(arr)) for(let i=0;i<arr.length;i+=2) out[arr[i]]=arr[i+1];
  return out;
}

/* sets */
export async function sadd(key: string, member: string) {
  if (MODE === "memory") { const e=ensure(key,"set"); (e.val as Set<string>).add(member); return; }
  await pipe([["SADD", key, member]]);
}
export async function sismember(key: string, member: string) {
  if (MODE === "memory") { const e=alive(key); return e?.type==="set" && (e.val as Set<string>).has(member) ? 1:0; }
  const [n] = await pipe([["SISMEMBER", key, member]]); return n === 1;
}

/* zsets */
export async function zadd(key: string, score: number, member: string) {
  if (MODE === "memory") { const e=ensure(key,"zset"); (e.val as Map<string,number>).set(member,score); return; }
  await pipe([["ZADD", key, score, member]]);
}
export async function zrem(key: string, member: string) {
  if (MODE === "memory") { const e=alive(key); if (e?.type==="zset") (e.val as Map<string,number>).delete(member); return; }
  await pipe([["ZREM", key, member]]);
}
export async function zcard(key: string) {
  if (MODE === "memory") { const e=alive(key); return e?.type==="zset" ? (e.val as Map<string,number>).size : 0; }
  const [n] = await pipe([["ZCARD", key]]); return Number(n||0);
}
export async function zrange(key: string, start=0, stop=49): Promise<string[]> {
  if (MODE === "memory") {
    const e=alive(key); if (e?.type!=="zset") return [];
    const arr=[... (e.val as Map<string,number>).entries()].sort((a,b)=>a[1]-b[1]).map(([m])=>m);
    return arr.slice(start, stop+1);
  }
  const [res] = await pipe([["ZRANGE", key, start, stop]]);
  return Array.isArray(res)? res: [];
}
function parseScore(s: string){ let excl=false; if (s.startsWith("(")){ excl=true; s=s.slice(1); }
  if (s==="inf"||s==="+inf") return {v:Infinity,excl}; if (s==="-inf") return {v:-Infinity,excl};
  return {v: Number(s), excl};
}
export async function zremrangebyscore(key: string, min: string, max: string) {
  if (MODE === "memory") {
    const e=alive(key); if (e?.type!=="zset") return;
    const {v:mn,excl:exMn}=parseScore(min), {v:mx,excl:exMx}=parseScore(max);
    const z = e.val as Map<string,number>;
    for (const [m,sc] of [...z.entries()]) {
      const geMin = exMn ? sc>mn : sc>=mn;
      const leMax = exMx ? sc<mx : sc<=mx;
      if (geMin && leMax) z.delete(m);
    }
    return;
  }
  await pipe([["ZREMRANGEBYSCORE", key, min, max]]);
}

/* lists */
export async function lpush(key: string, val: string) {
  if (MODE === "memory") { const e=ensure(key,"list"); (e.val as string[]).unshift(val); return; }
  await pipe([["LPUSH", key, val]]);
}
export async function lrange(key: string, start=0, stop=49) {
  if (MODE === "memory") { const e=alive(key); const a=e?.type==="list"?(e.val as string[]):[]; return a.slice(start, stop+1); }
  const [res] = await pipe([["LRANGE", key, start, stop]]); return Array.isArray(res)? res: [];
}
export async function ltrim(key: string, start: number, stop: number) {
  if (MODE === "memory") { const e=alive(key); if (e?.type==="list") e.val=(e.val as string[]).slice(start, stop+1); return; }
  await pipe([["LTRIM", key, start, stop]]);
}

/* simple counter rate limit: limit N/ windowSec */
export async function rateLimit(key: string, limit: number, windowSec: number) {
  if (MODE === "memory") {
    const bucket = `__rl:${key}:${Math.floor(now()/(windowSec*1000))}`;
    const e = ensure(bucket,"ctr"); e.val = Number(e.val||0) + 1; e.exp = now()+windowSec*1000;
    return e.val <= limit;
  }
  const bucket = `rl:${key}:${Math.floor(Date.now()/(windowSec*1000))}`;
  const res = await pipe([["INCR", bucket], ["EXPIRE", bucket, windowSec]]);
  const count = Number(res?.[0] || 0);
  return count <= limit;
}
TS

echo "=== 3) qlen: Ø§Ù„Ø¥Ø¨Ù„Ø§Øº Ø¹Ù† MODE ÙØ¹Ù„ÙŠ (redis|memory) Ù…Ø¹ Ø¹Ø¯Ù… Ø±Ù…ÙŠ 500 ==="
cat > src/app/api/rtc/qlen/route.ts <<'TS'
import { NextResponse } from "next/server";
import { zcard, zremrangebyscore, MODE } from "@/lib/rtc/upstash";
export const runtime = "nodejs";
export async function GET() {
  try {
    const cutoff = Date.now() - 60_000;
    await zremrangebyscore(`rtc:q`, "-inf", `(${cutoff}`);
    const len = await zcard(`rtc:q`);
    return NextResponse.json({ mode: MODE, len: Number(len || 0) }, { status: 200 });
  } catch (e: any) {
    return NextResponse.json({ mode: MODE === "redis" ? "redis-fail" : "memory", len: 0, error: String(e?.message||e).slice(0,120) }, { status: 200 });
  }
}
TS

echo "=== 4) Ø³ÙƒØ±Ø¨Øª Ù‚Ø¨ÙˆÙ„ Ù…ÙØ­Ø¯Ù‘Ø« (ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø£Ùˆ Ø±ÙØ¯ÙØ³) ==="
mkdir -p _ops || true
cat > _ops/acc_rtc.sh <<'SH'
#!/usr/bin/env bash
set -euo pipefail
BASE="${1:-https://www.ditonachat.com}"
say(){ printf "\n== %s ==\n" "$*"; }
code(){ curl -s -o /dev/null -w "%{http_code}" "$@"; }
json(){ curl -s "$@"; }
TMPDIR="${TMPDIR:-/tmp}"
JAR_A="$TMPDIR/ditona_anon_A.jar"; JAR_B="$TMPDIR/ditona_anon_B.jar"
rm -f "$JAR_A" "$JAR_B"

say "1) Init anon cookies"
curl -s -c "$JAR_A" "$BASE/api/anon/init" >/dev/null
curl -s -c "$JAR_B" "$BASE/api/anon/init" >/dev/null

say "2) Queue mode"
MODE=$(curl -s "$BASE/api/rtc/qlen" | sed -n 's/.*"mode":"\([^"]\+\)".*/\1/p'); echo "MODE=$MODE"

say "3) Enqueue A/B"
code -b "$JAR_A" -H "content-type: application/json" -X POST -d '{"gender":"u","country":"US","filterGenders":"all","filterCountries":"ALL"}' "$BASE/api/rtc/enqueue" | xargs echo "A enqueue:"
code -b "$JAR_B" -H "content-type: application/json" -X POST -d '{"gender":"u","country":"US","filterGenders":"all","filterCountries":"ALL"}' "$BASE/api/rtc/enqueue" | xargs echo "B enqueue:"

say "4) Matchmake"
R_A=$(curl -s -b "$JAR_A" -X POST "$BASE/api/rtc/matchmake"); echo "A: $R_A"
PAIR=$(echo "$R_A" | sed -n 's/.*"pairId":"\([^"]\+\)".*/\1/p'); ROLE_A=$(echo "$R_A" | sed -n 's/.*"role":"\([^"]\+\)".*/\1/p')
R_B=$(curl -s -b "$JAR_B" -X POST "$BASE/api/rtc/matchmake"); echo "B: $R_B"
PAIR_B=$(echo "$R_B" | sed -n 's/.*"pairId":"\([^"]\+\)".*/\1/p'); ROLE_B=$(echo "$R_B" | sed -n 's/.*"role":"\([^"]\+\)".*/\1/p')
echo "Expected: same pairId; roles caller/callee"
echo "Actual:   A:$PAIR ($ROLE_A)  B:$PAIR_B ($ROLE_B)"
test -n "$PAIR" && [ "$PAIR" = "$PAIR_B" ] || { echo "âœ— Matchmake failed"; exit 1; }

say "5) Offer/Answer"
code -b "$JAR_A" -H "content-type: application/json" -X POST -d "{\"pairId\":\"$PAIR\",\"sdp\":\"v=0-dummy-offer\"}" "$BASE/api/rtc/offer" | xargs echo "A POST /offer:"
curl -s -b "$JAR_B" "$BASE/api/rtc/offer?pairId=$PAIR" | sed 's/.*/B GET \/offer: &/'
code -b "$JAR_B" -H "content-type: application/json" -X POST -d "{\"pairId\":\"$PAIR\",\"sdp\":\"v=0-dummy-answer\"}" "$BASE/api/rtc/answer" | xargs echo "B POST /answer:"
curl -s -b "$JAR_A" "$BASE/api/rtc/answer?pairId=$PAIR" | sed 's/.*/A GET \/answer: &/'

say "6) ICE exchange"
code -b "$JAR_A" -H "content-type: application/json" -X POST -d "{\"pairId\":\"$PAIR\",\"candidate\":{\"candidate\":\"candA\",\"sdpMid\":\"0\",\"sdpMLineIndex\":0}}" "$BASE/api/rtc/ice" | xargs echo "A POST /ice:"
curl -s -b "$JAR_B" "$BASE/api/rtc/ice?pairId=$PAIR" | sed 's/.*/B GET \/ice: &/'
code -b "$JAR_B" -H "content-type: application/json" -X POST -d "{\"pairId\":\"$PAIR\",\"candidate\":{\"candidate\":\"candB\",\"sdpMid\":\"0\",\"sdpMLineIndex\":0}}" "$BASE/api/rtc/ice" | xargs echo "B POST /ice:"
curl -s -b "$JAR_A" "$BASE/api/rtc/ice?pairId=$PAIR" | sed 's/.*/A GET \/ice: &/'

say "7) qlen (final)"
curl -s "$BASE/api/rtc/qlen" | sed 's/.*/qlen: &/'

say "SUMMARY"
echo "MODE=$MODE (memory during bring-up; expected 'redis' after env fix)"
echo "Match + SDP/ICE via REST OK if above steps succeeded."
SH
chmod +x _ops/acc_rtc.sh

echo "=== 5) ØªØ«Ø¨ÙŠØª ÙˆØ¨Ù†Ø§Ø¡ ==="
pnpm install
pnpm build

echo "=== 6) ØªØ´ØºÙŠÙ„ Ø§Ù„Ù‚Ø¨ÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ù†ØªØ§Ø¬ ==="
bash _ops/acc_rtc.sh https://www.ditonachat.com || (echo 'ACCEPTANCE FAILED' && exit 1)

echo "=== 7) Ø§Ù„ØªØ²Ø§Ù… Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ==="
git add -A
git commit -m "RTC: Upstash memory fallback + qlen mode; acceptance script"
echo "DONE. Ø§ÙØªØ­ PR Ø¥Ù„Ù‰ main Ù…Ø¹ Ù„Ù‚Ø·Ø§Øª/Ù†ØªØ§Ø¦Ø¬ acc."

ğŸ§ª Ù…Ø§ Ø§Ù„Ø°ÙŠ Ø³Ù†ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡ Ø¨Ø¹Ø¯ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¨Ø§ØªØ´ØŸ

Ù„Ù† ØªØ±Ù‰ 500 Ø¹Ù„Ù‰ /api/rtc/enqueue|matchmake|qlen Ø­ØªÙ‰ Ø¨Ø¯ÙˆÙ† Ù…ÙØ§ØªÙŠØ­ Upstash.

/api/rtc/qlen Ø³ÙŠØ¹Ø±Ø¶ {"mode":"memory","len":...} Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† redis-fail.

ØªØ´ØºÙŠÙ„ bash _ops/acc_rtc.sh https://www.ditonachat.com ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙØ¸Ù‡Ø±:

pairId ÙˆØ§Ø­Ø¯ Ù„Ù„Ø·Ø±ÙÙŠÙ† (caller/callee).

Ù†Ø¬Ø§Ø­ offer/answer/ice (POST=204 Ø£Ùˆ 409ØŒ ÙˆGET ÙŠØ¹ÙŠØ¯ JSON/array).

Ø«Ù… ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ØªØ£ÙƒØ¯ Ø¨ØµØ±ÙŠÙ‹Ø§ Ù…Ù† Ø¬Ù‡Ø§Ø²ÙŠÙ† Ø£Ù† Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙŠØ¹Ù…Ù„.

Ù„Ùˆ ÙØ´Ù„ acc_rtc.sh Ø¨Ø¹Ø¯ Ù‡Ø°Ù‡ Ø§Ù„Ø¯ÙØ¹Ø©: Ø£Ø±Ø³Ù„ Ù„Ù†Ø§ Ù†Øµ Ø§Ù„Ø®Ø±Ø¬ Ø§Ù„ÙƒØ§Ù…Ù„. Ø§Ù„ÙØ´Ù„ Ø§Ù„ÙˆØ­ÙŠØ¯ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹ Ø§Ù„Ø¢Ù† Ù‡Ùˆ Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ ÙƒÙˆÙƒÙŠ anon (Ù†Ø§Ø¯Ø±Ø› init ÙŠÙØ¹Ø§Ù„Ø¬Ù‡)ØŒ Ø£Ùˆ Ø®Ø·Ø£ JS ÙÙŠ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø®Ø§Ø±Ø¬ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³Ø§Ø±.

ğŸ”§ Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„ØªØ§Ù„ÙŠØ© (Ø¥Ù„Ø²Ø§Ù…ÙŠØ© Ù„Ø¹ÙˆØ¯Ø© Ø§Ù„ÙˆØ¶Ø¹ Ø¥Ù„Ù‰ Redis)

Ø¨Ø¹Ø¯ Ø£Ù† ØªØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ø§ØªØµØ§Ù„ ÙŠØ¹Ù…Ù„ ÙÙŠ memory:

Ø§Ø¯Ø®Ù„ Vercel â†’ Project â†’ Settings â†’ Environment Variables ÙˆØ£Ø¶Ù ÙÙŠ Production + Preview:

UPSTASH_REDIS_REST_URL

UPSTASH_REDIS_REST_TOKEN

Ø£Ø¹Ø¯ Ø§Ù„Ù†Ø´Ø±.

ØªØ­Ù‚Ù‚:

curl -s https://www.ditonachat.com/api/rtc/qlen | jq .
# Expected: { "mode": "redis", "len": ... }


Ø£Ø¹Ø¯ ØªØ´ØºÙŠÙ„ bash _ops/acc_rtc.sh https://www.ditonachat.com ÙˆØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…Ø±ÙˆØ± (Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø¢Ù† MODE=redis).

Ù…Ù‡Ù…: Ø§Ù„Ù€fallback Ø§Ù„Ø°Ø§ÙƒØ±ÙŠ Ø­Ù„ ØªØ´ØºÙŠÙ„ Ù…Ø¤Ù‚Øª Ù„ØªÙØ§Ø¯ÙŠ 500 ÙÙˆØ±Ù‹Ø§ ÙˆØªÙ…ÙƒÙŠÙ† Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø› Ù†Ø¹ÙˆØ¯ Ø¥Ù„Ù‰ Redis Ø¨Ù…Ø¬Ø±Ø¯ Ø¶Ø¨Ø· Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª. Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØºÙŠÙŠØ±Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ© Ù…Ø·Ù„ÙˆØ¨Ø©.

ğŸ§¾ ØªÙ‚Ø±ÙŠØ± Ù…Ø·Ù„ÙˆØ¨ Ù…Ù† Ø§Ù„ÙˆÙƒÙŠÙ„ Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡

Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø¹Ø¯Ù‘Ù„Ø© (Ù…Ø¹ Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ù„Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© ÙÙŠ _ops/backup).

Ù…Ø®Ø±Ø¬Ø§Øª acc_rtc.sh (Expected/Actual + MODE).

Ù„Ù‚Ø·Ø© Ø´Ø§Ø´Ø© Ù…Ù† Ø¬Ù‡Ø§Ø²ÙŠÙ† Ø£Ø«Ù†Ø§Ø¡ Ø§ØªØµØ§Ù„ ÙØ¹Ù„ÙŠ.

ØªØ£ÙƒÙŠØ¯ Ø£Ù† Ù„Ø§ Ù…ÙŠØ²Ø© Ø­ÙØ°ÙØª ÙˆÙ„Ø§ ØªØºÙŠÙŠØ±Ø§Øª Ø¨ØµØ±ÙŠØ© Ø­Ø¯Ø«Øª.