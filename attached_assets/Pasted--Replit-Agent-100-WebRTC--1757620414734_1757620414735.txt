๐ฆ ุฑุณุงูุฉ ุฌุงูุฒุฉ ูููููู (Replit Agent)

ุงููููุฉ: ุฅุตูุงุญ ุฌุฐุฑู 100% ููุดููุฉ ุงูุชุฑุงู WebRTC ุงูุญุงููุฉุ ุจูุงุกู ุนูู ูุฑุงุกุฉ ุงูููุฏ ุงููุนูู (ุฃุฑุดูู ุงููุดุฑูุน ุงูุฃุฎูุฑ).
ููุงุฐุง: ุงููุดู ุงูุญุงูู ุณุจุจู ุฃู ุงููุงุฌูุฉ ูุง ุชุญูุธ pairId/role ูู /api/rtc/matchmakeุ ูุชุจุฏุฃ ุจุฅุฑุณุงู SDP/ICE ุจุฏูู pairIdุ ููุง ุฃู ูุณุงุฑุงุช answer/ice ุชุณุชุฎุฏู ุชูุซูููุง ููุฑุฌุน null ุฏุงุฆููุงุ ุฅุถุงูุฉู ูุงุณุชุฎุฏุงู ูุฏูู ูู/api/rtc/enqueue ูุง ูุถุจุท attrs/filters.
ููู: MinimalโDiff ุจุงุชุดุงุช ูุญุฏูุฏุฉ ููููุงุช ุจุนูููุง + ุณูุฑุจุช ูุจูู ููุงุฆู. ููููุน ุญุฐู/ุชุนุทูู ุฃู ููุฒุฉ ุฃู ุชุบููุฑ ุจุตุฑู ุงูุชุฑุงุถู.

๐ฆ ูุจู ุงูุจุฏุก (ูุง ุชุบููุฑุงุช ูู ุงูุจูุฆุฉ)

ุชุฃููุฏ ููุท ูู ูุฌูุฏ ุงููุชุบูุฑุงุช ุงูุชุงููุฉ ุนูู Vercel / ุจูุฆุฉ ุงูุชุดุบูู (ููููุง ููุฌูุฏุฉ ุฃุตููุง ูุฏู ุงููุงูู):

UPSTASH_REDIS_REST_URL, UPSTASH_REDIS_REST_TOKEN

ANON_SIGNING_SECRET (ุฃู ุจุฏููู ุงูุญุงูู VIP_SIGNING_SECRET)

FREE_FOR_ALL=1, NEXT_PUBLIC_FREE_FOR_ALL=1 (ููุจูู ุชุฌุฑุจุฉ ุงููุณุชุฎุฏู ูุฌุงููุฉ ุงูุขู)

ููุงุญุธุฉ: ูุณุงุฑ /api/anon/init ููุฌูุฏ ูุชููุฆุฉ ูููู anon ุงูููููุน.

๐งฉ ุงูุชูููุฐ (ุฃูุงูุฑ ูุตู ูุชุดุบูู ุฏูุนุฉ ูุงุญุฏุฉ)

ููู: ุงูุนูู ูู ุฌุฐุฑ ุงููุณุชูุฏุน ( ุฌููุน ุงูุฃูุงูุฑ Idempotent ููููู ุชูุฑุงุฑูุง ุนูุฏ ุงูุญุงุฌุฉ.

#!/usr/bin/env bash
set -euo pipefail

# 0) ุชุญุถูุฑ ูุฑุน ุขูู
git checkout -b feature/rtc-fix-final || git checkout feature/rtc-fix-final || true

# 1) ูุณุฎ ุงุญุชูุงุทู ุณุฑูุน ูููููุงุช ุงููุณุชูุฏูุฉ
mkdir -p _ops/backup || true
cp -f src/app/chat/rtcFlow.ts _ops/backup/rtcFlow.ts.bak 2>/dev/null || true
cp -f src/app/api/rtc/enqueue/route.ts _ops/backup/enqueue.route.ts.bak 2>/dev/null || true
cp -f src/app/api/rtc/offer/route.ts   _ops/backup/offer.route.ts.bak   2>/dev/null || true
cp -f src/app/api/rtc/answer/route.ts  _ops/backup/answer.route.ts.bak  2>/dev/null || true
cp -f src/app/api/rtc/ice/route.ts     _ops/backup/ice.route.ts.bak     2>/dev/null || true
cp -f src/app/api/rtc/qlen/route.ts    _ops/backup/qlen.route.ts.bak    2>/dev/null || true
cp -f _ops/acc_rtc.sh                  _ops/backup/acc_rtc.sh.bak       2>/dev/null || true

###############################################################################
# 2) ุงุณุชุจุฏุงู ูุญุชูู ุงููููุงุช (Minimal-Diff) โ ุฌุงูุฒ ูููุตู
###############################################################################

# 2.1 ูุงุฌูุฉ RTC: ุญูุธ pairId/role ูู matchmake ูุชูุฑูุฑููุง ุฅูู offer/answer/ice
cat > src/app/chat/rtcFlow.ts <<'TSX'
/* Minimal RTC client flow: enqueue -> matchmake -> offer/answer -> ice (REST only) */
export async function startRtcFlow() {
  try {
    // 0) ุชููุฆุฉ ูููู anon ุงูููููุน (ุฅู ูู ููุฌุฏ)
    await fetch("/api/anon/init", { method: "GET", cache: "no-store" }).catch(() => {});

    // 1) Enqueue (ุณูุงุช + ููุงุชุฑ). ุงููุงุฌูุฉ ูููููุง ุชูุฑูุฑ ุฌุณู ุงุฎุชูุงุฑู:
    const body = (window as any).__ditonaEnqueueBody || {};
    await fetch("/api/rtc/enqueue", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(body),
    });

    // 2) Matchmake: 204 โ backoff 300โ800msุ 200 โ {pairId, role}
    let pairId: string | undefined;
    let role: "caller" | "callee" | undefined;
    for (let i = 0; i < 50; i++) {
      const r = await fetch("/api/rtc/matchmake", { method: "POST", cache: "no-store" });
      if (r.status === 200) {
        const j = await r.json().catch(() => ({}));
        pairId = j?.pairId; role = j?.role;
        if (pairId && role) break;
      }
      await new Promise(res => setTimeout(res, 300 + Math.floor(Math.random() * 500)));
    }
    if (!pairId || !role) throw new Error("matchmake-timeout");

    // 3) ุฅูุดุงุก RTCPeerConnection
    const pc = new RTCPeerConnection();
    const remote = document.getElementById("remoteVideo") as HTMLVideoElement | null;
    pc.ontrack = (ev) => {
      const s = ev.streams?.[0] || new MediaStream([ev.track]);
      if (remote) {
        remote.srcObject = s;
        remote.muted = true;
        remote.playsInline = true;
        remote.autoplay = true as any;
        remote.play?.().catch(() => {});
      }
    };
    // ุฅุถุงูุฉ ุงููุณุงุฑุงุช ุงููุญููุฉ ุฅู ููุฌุฏุช
    const local: MediaStream | undefined = (window as any).__localStream;
    if (local) local.getTracks().forEach(t => pc.addTrack(t, local));

    // 4) ICE: POST ุฅูู /api/rtc/ice + Poll GET
    pc.onicecandidate = async (e) => {
      if (!e.candidate) return;
      try {
        await fetch("/api/rtc/ice", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ pairId, candidate: e.candidate }),
        });
      } catch {}
    };
    const pollIce = async () => {
      try {
        const r = await fetch(`/api/rtc/ice?pairId=${encodeURIComponent(String(pairId))}`, { cache: "no-store" });
        if (r.status === 200) {
          const arr = await r.json().catch(() => []);
          for (const it of arr) {
            try { await pc.addIceCandidate(it.cand); } catch {}
          }
        }
      } catch {}
    };
    const iceTimer = setInterval(pollIce, 350 + Math.floor(Math.random() * 350));

    // 5) ุชุจุงุฏู SDP via REST
    if (role === "caller") {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await fetch("/api/rtc/offer", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ pairId, sdp: JSON.stringify(offer) }),
      });
      // Poll answer
      for (;;) {
        const g = await fetch(`/api/rtc/answer?pairId=${encodeURIComponent(String(pairId))}`, { cache: "no-store" });
        if (g.status === 200) {
          const { sdp } = await g.json().catch(() => ({}));
          if (sdp) { await pc.setRemoteDescription(JSON.parse(sdp)); break; }
        }
        await new Promise(res => setTimeout(res, 300 + Math.floor(Math.random() * 400)));
      }
    } else {
      // callee: poll offer โ create answer โ POST answer
      for (;;) {
        const g = await fetch(`/api/rtc/offer?pairId=${encodeURIComponent(String(pairId))}`, { cache: "no-store" });
        if (g.status === 200) {
          const { sdp } = await g.json().catch(() => ({}));
          if (sdp) {
            await pc.setRemoteDescription(JSON.parse(sdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            await fetch("/api/rtc/answer", {
              method: "POST",
              headers: { "content-type": "application/json" },
              body: JSON.stringify({ pairId, sdp: JSON.stringify(answer) }),
            });
            break;
          }
        }
        await new Promise(res => setTimeout(res, 300 + Math.floor(Math.random() * 400)));
      }
    }

    // ุฅุชุงุญุฉ ุชูุธูู ุงููุคูุช ุนูุฏ ุงูุฅููุงุก
    (pc as any).__ditonaCleanup = () => clearInterval(iceTimer);
  } catch (e) {
    console.warn("RTC flow error", e);
  }
}
TSX

# 2.2 ุฌุนู enqueue ูุถุจุท attrs/filters ูุนูููุง (ุจุฏู qPush ุงููุฏูู)
cat > src/app/api/rtc/enqueue/route.ts <<'TS'
import { NextRequest, NextResponse } from "next/server";
import { extractAnonId } from "@/lib/rtc/auth";
import { enqueue } from "@/lib/rtc/mm";
export const runtime = "nodejs";

export async function OPTIONS() { return NextResponse.json({ ok: true }); }

export async function POST(req: NextRequest) {
  try {
    const anon = extractAnonId(req);
    if (!anon) return NextResponse.json({ error: "anon-required" }, { status: 403 });

    const b: any = await req.json().catch(() => ({}));
    const gender = String(b.gender || "u").toLowerCase();
    const country = String(b.country || req.headers.get("x-vercel-ip-country") || "XX").toUpperCase();
    const filterGenders = String(b.filterGenders || "all");
    const filterCountries = String(b.filterCountries || "ALL");

    await enqueue(anon, { gender, country }, { genders: filterGenders, countries: filterCountries });
    return new NextResponse(null, { status: 204 });
  } catch (e: any) {
    return NextResponse.json({ error: "enqueue-fail", info: String(e?.message || e).slice(0, 140) }, { status: 500 });
  }
}
TS

# 2.3 offer: ุชูุซูู ุตุญูุญ + ุชุฎุฒูู sdp ูุณูุณูุฉ JSON + ุชูุฏูุฏ TTL
cat > src/app/api/rtc/offer/route.ts <<'TS'
import { NextRequest, NextResponse } from "next/server";
import { extractAnonId } from "@/lib/rtc/auth";
import { get, setNxPx, expire } from "@/lib/rtc/upstash";
export const runtime = "nodejs";

async function auth(anon: string, pairId: string) {
  const map = await get(`rtc:pair:map:${anon}`); if (!map) return null;
  const [pid, role] = String(map).split("|");
  return pid === pairId ? role : null;
}

export async function POST(req: NextRequest) {
  try {
    const anon = extractAnonId(req); if (!anon) return NextResponse.json({ error: "anon-required" }, { status: 403 });
    const { pairId, sdp } = await req.json().catch(() => ({}));
    if (!pairId || !sdp) return NextResponse.json({ error: "bad-input" }, { status: 400 });

    const role = await auth(anon, pairId);
    if (role !== "caller") return NextResponse.json({ error: "only-caller" }, { status: 403 });

    const sdpStr = typeof sdp === "string" ? sdp : JSON.stringify(sdp);
    const ok = await setNxPx(`rtc:pair:${pairId}:offer`, sdpStr, 120_000);
    if (!ok) return NextResponse.json({ error: "exists" }, { status: 409 });

    await expire(`rtc:pair:${pairId}`, 150);
    return new NextResponse(null, { status: 204 });
  } catch (e: any) {
    return NextResponse.json({ error: "offer-fail", info: String(e?.message || e).slice(0, 140) }, { status: 500 });
  }
}

export async function GET(req: NextRequest) {
  const anon = extractAnonId(req); if (!anon) return NextResponse.json({ error: "anon-required" }, { status: 403 });
  const pairId = String(new URL(req.url).searchParams.get("pairId") || "");
  if (!pairId) return NextResponse.json({ error: "bad-input" }, { status: 400 });

  const role = await auth(anon, pairId); if (role !== "callee") return NextResponse.json({ error: "only-callee" }, { status: 403 });
  const sdp = await get(`rtc:pair:${pairId}:offer`); if (!sdp) return new NextResponse(null, { status: 204 });

  await expire(`rtc:pair:${pairId}`, 150);
  return NextResponse.json({ sdp: String(sdp) }, { status: 200 });
}
TS

# 2.4 answer: ุงุณุชุจุฏุงู getAnonIdUnsafe โ extractAnonId + JSON sdp
cat > src/app/api/rtc/answer/route.ts <<'TS'
import { NextRequest, NextResponse } from "next/server";
import { extractAnonId } from "@/lib/rtc/auth";
import { get, setNxPx, expire } from "@/lib/rtc/upstash";
export const runtime = "nodejs";

async function auth(anon: string, pairId: string) {
  const map = await get(`rtc:pair:map:${anon}`); if (!map) return null;
  const [pid, role] = String(map).split("|");
  return pid === pairId ? role : null;
}

export async function POST(req: NextRequest) {
  try {
    const anon = extractAnonId(req); if (!anon) return NextResponse.json({ error: "anon-required" }, { status: 403 });
    const { pairId, sdp } = await req.json().catch(() => ({}));
    if (!pairId || !sdp) return NextResponse.json({ error: "bad-input" }, { status: 400 });

    const role = await auth(anon, pairId);
    if (role !== "callee") return NextResponse.json({ error: "only-callee" }, { status: 403 });

    const sdpStr = typeof sdp === "string" ? sdp : JSON.stringify(sdp);
    const ok = await setNxPx(`rtc:pair:${pairId}:answer`, sdpStr, 120_000);
    if (!ok) return NextResponse.json({ error: "exists" }, { status: 409 });

    await expire(`rtc:pair:${pairId}`, 150);
    return new NextResponse(null, { status: 204 });
  } catch (e: any) {
    return NextResponse.json({ error: "answer-fail", info: String(e?.message || e).slice(0, 140) }, { status: 500 });
  }
}

export async function GET(req: NextRequest) {
  const anon = extractAnonId(req); if (!anon) return NextResponse.json({ error: "anon-required" }, { status: 403 });
  const pairId = String(new URL(req.url).searchParams.get("pairId") || "");
  if (!pairId) return NextResponse.json({ error: "bad-input" }, { status: 400 });

  const role = await auth(anon, pairId); if (role !== "caller") return NextResponse.json({ error: "only-caller" }, { status: 403 });
  const sdp = await get(`rtc:pair:${pairId}:answer`); if (!sdp) return new NextResponse(null, { status: 204 });

  await expire(`rtc:pair:${pairId}`, 150);
  return NextResponse.json({ sdp: String(sdp) }, { status: 200 });
}
TS

# 2.5 ice: ุงุณุชุจุฏุงู getAnonIdUnsafe โ extractAnonId + ุญุงุฑุณ ุฃุฎุทุงุก ูุฏุนู pairId
cat > src/app/api/rtc/ice/route.ts <<'TS'
import { NextRequest, NextResponse } from "next/server";
import { extractAnonId } from "@/lib/rtc/auth";
import { get, lpush, lrange, ltrim, expire } from "@/lib/rtc/upstash";
export const runtime = "nodejs";

async function auth(anon: string, pairId: string) {
  const map = await get(`rtc:pair:map:${anon}`); if (!map) return null;
  const [pid, role] = String(map).split("|"); if (pid !== pairId) return null;
  return role as "caller" | "callee";
}

export async function POST(req: NextRequest) {
  try {
    const anon = extractAnonId(req); if (!anon) return NextResponse.json({ error: "anon-required" }, { status: 403 });
    const { pairId, candidate } = await req.json().catch(() => ({}));
    if (!pairId || !candidate) return NextResponse.json({ error: "bad-input" }, { status: 400 });

    const role = await auth(anon, pairId); if (!role) return NextResponse.json({ error: "forbidden" }, { status: 403 });
    const dest = role === "caller" ? "b" : "a";
    const key = `rtc:pair:${pairId}:ice:${dest}`;
    await lpush(key, JSON.stringify({ from: role === "caller" ? "a" : "b", cand: candidate }));
    await expire(key, 150); await expire(`rtc:pair:${pairId}`, 150);
    return new NextResponse(null, { status: 204 });
  } catch (e: any) {
    return NextResponse.json({ error: "ice-post-fail", info: String(e?.message || e).slice(0, 140) }, { status: 500 });
  }
}

export async function GET(req: NextRequest) {
  const anon = extractAnonId(req); if (!anon) return NextResponse.json({ error: "anon-required" }, { status: 403 });
  const pairId = String(new URL(req.url).searchParams.get("pairId") || "");
  if (!pairId) return NextResponse.json({ error: "bad-input" }, { status: 400 });

  const role = await auth(anon, pairId); if (!role) return NextResponse.json({ error: "forbidden" }, { status: 403 });
  const me = role === "caller" ? "a" : "b";
  const key = `rtc:pair:${pairId}:ice:${me}`;
  const items = await lrange(key, 0, 49);
  if (!items || items.length === 0) return new NextResponse(null, { status: 204 });
  await ltrim(key, items.length, -1); await expire(`rtc:pair:${pairId}`, 150);
  return NextResponse.json(items.map(s => JSON.parse(s)), { status: 200 });
}
TS

# 2.6 qlen: ูุง ูุฑูู 500 ุนูุฏ ูุดู Upstash โ ููุนูุฏ {mode:"redis-fail", len:0}
cat > src/app/api/rtc/qlen/route.ts <<'TS'
import { NextResponse } from "next/server";
import { zcard, zremrangebyscore } from "@/lib/rtc/upstash";
export const runtime = "nodejs";
export async function GET() {
  try {
    const cutoff = Date.now() - 60_000;
    await zremrangebyscore(`rtc:q`, "-inf", `(${cutoff}`);
    const len = await zcard(`rtc:q`);
    return NextResponse.json({ mode: "redis", len: Number(len || 0) }, { status: 200 });
  } catch (e: any) {
    return NextResponse.json({ mode: "redis-fail", len: 0, error: String(e?.message || e).slice(0,120) }, { status: 200 });
  }
}
TS

# 2.7 ุณูุฑุจุช ูุจูู ููุงุฆู ูุนุชูุฏ ูููู anon (ุฅูุชุงุฌ)
mkdir -p _ops || true
cat > _ops/acc_rtc.sh <<'SH'
#!/usr/bin/env bash
set -euo pipefail
BASE="${1:-https://www.ditonachat.com}"
say(){ printf "\n== %s ==\n" "$*"; }
code(){ curl -s -o /dev/null -w "%{http_code}" "$@"; }
json(){ curl -s "$@"; }
TMPDIR="${TMPDIR:-/tmp}"
JAR_A="$TMPDIR/ditona_anon_A.jar"; JAR_B="$TMPDIR/ditona_anon_B.jar"
rm -f "$JAR_A" "$JAR_B"

say "1) Init anon cookies"
curl -s -c "$JAR_A" "$BASE/api/anon/init" >/dev/null
curl -s -c "$JAR_B" "$BASE/api/anon/init" >/dev/null

say "2) Enqueue A and B"
code -b "$JAR_A" -H "content-type: application/json" -X POST -d '{"gender":"u","country":"US","filterGenders":"all","filterCountries":"ALL"}' "$BASE/api/rtc/enqueue" | xargs echo "A enqueue:"
code -b "$JAR_B" -H "content-type: application/json" -X POST -d '{"gender":"u","country":"US","filterGenders":"all","filterCountries":"ALL"}' "$BASE/api/rtc/enqueue" | xargs echo "B enqueue:"

say "3) Matchmake"
R_A=$(curl -s -b "$JAR_A" -X POST "$BASE/api/rtc/matchmake"); echo "A: $R_A"
PAIR=$(echo "$R_A" | sed -n 's/.*"pairId":"\([^"]\+\)".*/\1/p'); ROLE_A=$(echo "$R_A" | sed -n 's/.*"role":"\([^"]\+\)".*/\1/p')
R_B=$(curl -s -b "$JAR_B" -X POST "$BASE/api/rtc/matchmake"); echo "B: $R_B"
PAIR_B=$(echo "$R_B" | sed -n 's/.*"pairId":"\([^"]\+\)".*/\1/p'); ROLE_B=$(echo "$R_B" | sed -n 's/.*"role":"\([^"]\+\)".*/\1/p')
echo "Expected: same pairId; roles caller/callee"
echo "Actual:   A:$PAIR ($ROLE_A)  B:$PAIR_B ($ROLE_B)"
if [ -z "$PAIR" ] || [ "$PAIR" != "$PAIR_B" ]; then echo "โ Matchmake failed"; exit 1; fi

say "4) Offer/Answer"
code -b "$JAR_A" -H "content-type: application/json" -X POST -d "{\"pairId\":\"$PAIR\",\"sdp\":\"v=0-dummy-offer\"}" "$BASE/api/rtc/offer" | xargs echo "A POST /offer:"
curl -s -b "$JAR_B" "$BASE/api/rtc/offer?pairId=$PAIR" | sed 's/.*/B GET \/offer: &/'
code -b "$JAR_B" -H "content-type: application/json" -X POST -d "{\"pairId\":\"$PAIR\",\"sdp\":\"v=0-dummy-answer\"}" "$BASE/api/rtc/answer" | xargs echo "B POST /answer:"
curl -s -b "$JAR_A" "$BASE/api/rtc/answer?pairId=$PAIR" | sed 's/.*/A GET \/answer: &/'

say "5) ICE exchange"
code -b "$JAR_A" -H "content-type: application/json" -X POST -d "{\"pairId\":\"$PAIR\",\"candidate\":{\"candidate\":\"candA\",\"sdpMid\":\"0\",\"sdpMLineIndex\":0}}" "$BASE/api/rtc/ice" | xargs echo "A POST /ice:"
curl -s -b "$JAR_B" "$BASE/api/rtc/ice?pairId=$PAIR" | sed 's/.*/B GET \/ice: &/'
code -b "$JAR_B" -H "content-type: application/json" -X POST -d "{\"pairId\":\"$PAIR\",\"candidate\":{\"candidate\":\"candB\",\"sdpMid\":\"0\",\"sdpMLineIndex\":0}}" "$BASE/api/rtc/ice" | xargs echo "B POST /ice:"
curl -s -b "$JAR_A" "$BASE/api/rtc/ice?pairId=$PAIR" | sed 's/.*/A GET \/ice: &/'

say "6) qlen (no 500)"
curl -s "$BASE/api/rtc/qlen" | sed 's/.*/qlen: &/'

say "SUMMARY"
echo "Expected: 200 on offer/answer posts; GET returns JSON; ICE GET returns array; qlen returns mode/len"
SH
chmod +x _ops/acc_rtc.sh

###############################################################################
# 3) ุชุซุจูุช ูุจูุงุก
###############################################################################
pnpm install
pnpm build

###############################################################################
# 4) ุชุดุบูู ุงููุจูู ุนูู ุงูุฅูุชุงุฌ (ุฏูู ุจูุงูุงุช ุญุณุงุณุฉ)
###############################################################################
bash _ops/acc_rtc.sh https://www.ditonachat.com || (echo "ACCEPTANCE FAILED" && exit 1)

###############################################################################
# 5) ุงูุชุฒุงู ุงูุชุบููุฑุงุช ููุชุญ PR ุฏุงุฎูู
###############################################################################
git add -A
git commit -m "RTC: Fix pairing via REST (pairId flow), auth extractAnonId, JSON SDP, enqueue attrs/filters, qlen fallback, acc script"
echo "DONE. Please open PR -> main with build & acc logs."

โ ูุง ุงูุฐู ููุตูุญ ุฌุฐุฑููุง ูู ูุฐู ุงูุฏูุนุฉุ

UI: rtcFlow.ts ุฃุตุจุญ:

ููููุฆ ูููู anonุ

ูุณุชุฏุนู /api/rtc/enqueue ููุท ูุถุจุท attrs/filtersุ

ูููpoll /api/rtc/matchmake ุญุชู ูุญุตู ุนูู {pairId, role}ุ

ููุฑุณู SDP ูุณูุณูุฉ JSON (ูููุณ [object Object]) ููุณุชูุจููุง ูุฐููุ

ูููุฑูุฑ pairId ููู offer/answer/iceุ ููููpoll ICE ุจุดูู ุขูู.

Server:

/api/rtc/enqueue ูุถุจุท rtc:attrs:* & rtc:filters:* (ุจุฏู qPush ุงููุฏูู)ุ

/api/rtc/answer ู/api/rtc/ice ุงุณุชุจุฏูุช getAnonIdUnsafe ุจู extractAnonId (ููู ูุนุฏุง ูุฑูุถุงู ุฏุงุฆููุง)ุ

offer/answer ูุฎุฒููุงู SDP ูุณูุณูุฉ JSONุ ููุฌุฏูุฏุงู TTL ูููpairุ

qlen ูุง ูุฑูู 500 ุนูุฏ ูุดู Upstash (fallback ูุงุถุญ).

ูุจูู: _ops/acc_rtc.sh:

ูุณุชุฎุฏู ูููู ููููุน ุนุจุฑ /api/anon/init (ุฌุงุฑุงู)ุ

ูุซุจุช ุฃู ุงูุทุฑููู ูุญุตูุงู ุนูู pairId ูุงุญุฏ ูุฃุฏูุงุฑ caller/calleeุ

ูุซุจุช ูุฌุงุญ offer/answer/ice ูุบูุงุจ 500 ูู qlen.

๐ ุชุญูู ุจุตุฑู ูุชููู (ูููููุฐู ุงููููู ูุจู ุงูุชุณููู)

ุงูุชุญ /chat ูู ุฌูุงู + ููุจููุชุฑ (ุฃู ูุงูุฐุชูู ูุณุชููุชูู)ุ ุงุถุบุท Next ูู ูููููุง โ
Expected: ุจุฏุก ุงูููุฏูู/ุงูุตูุช ูุนูููุงุ ูุธููุฑ ุดุฑูุท ุงูุญุงูุฉ โุฌุงุฑู ุงูุนุซูุฑ ุนูู ุดุฑููโฆโ ุซู ุงูุงุชุตุงู.

DevTools โ Network: ูุง ุชูุฌุฏ ุฃุฎุทุงุก 4xx/5xx ุนูู /api/rtc/*.

Headers: ูุง ุชุบููุฑ ุจุตุฑู ุงูุชุฑุงุถูุ ุงููCSP/PermissionsโPolicy ููุง ูู.

FREE_FOR_ALL=1: ูุง Upsell ุชููุงุฆูุ ููุง ุญูุงุฌุฒ VIP ุชุนุทู ุงูุชุฏูู.

๐งพ ุชุณููู ููุงุฆู ูู ุงููููู (ูุทููุจ)

ููุฎุต ุจูุง ุชู ุชุบููุฑู ููููุง ุจููู (ุณุทุฑูู ููู ููู).

ูุฎุฑุฌุงุช bash _ops/acc_rtc.sh https://www.ditonachat.com (Expected/Actual).

ููุทุฉ ุดุงุดุฉ ูู ุฌูุงุฒูู ุฃุซูุงุก ุงุชุตุงู ูุนูู (Desktop/Mobile).

ุชุฃููุฏ ุนุฏู ุญุฐู/ุชุนุทูู ุฃู ููุฒุฉ ูุงุฆูุฉุ ูุนุฏู ุชุบููุฑ ุงูุดูู ุงูุงูุชุฑุงุถู.

ููุงุญุธุฉ ุฃุฎูุฑุฉ

ุฅู ุตุงุฏูุช ุงุฎุชูุงููุง ุจุณูุทูุง ูู ูุณุงุฑุงุช ุงูุงุณุชูุฑุงุฏ (@/โฆ)ุ ุฃุตูุญู ูุญูููุง ุจุฏูู ุชุบููุฑ ููููุฉ ุงููุดุฑูุน.

ุฅู ูุดู ูุตู ุจุงุชุด ูุง ุจุณุจุจ ุงุฎุชูุงู ุณุงุจูุ ุงุณุชุจุฏู ูุญุชูู ุงูููู ุจุงููุงูู ุจุงููุต ุงููุฒูุฏ ุฃุนูุงู ููุง ูู.

ุฃู ูุดููุฉ ุซุงูููุฉ (Types/ESLint) ุฃุตูุญูุง ูุญูููุง ุจูุง ูุง ูุบููุฑ ุงูููุทู ุฃู ูุนุทู ููุฒุฉ.

ุจุนุฏ ุชุทุจูู ูุฐู ุงูุฏูุนุฉุ ุงูุงูุชุฑุงู ุนุจุฑ REST ุณูููู ูุณุชูุฑูุง ูููุงูููุง ูุณุจุงูุงุช ุงูุชูููุฐุ ูุงูุงุชุตุงู ุณูุนูู 100% ููุง ูู ูุทููุจ.

ูุฏ ูููุฑ ุชุทุจูู ChatGPT ูุนูููุงุช ุฎุงุทุฆุฉ. ูุง ุชููู OpenAI ุจุงุณุชุฎุฏุงู ุงูุจูุงูุงุช ูู ูุณุงุญุฉ ุงูุนูู mhamdaksam's Workspace ูุชุฏุฑูุจ ููุงุฐุฌูุง.